#include "./CppCommon/WaveFrontKernels.cuh"

#include "CppCommon/RenderingUtility.h"

using namespace WaveFront;
/*
 * Example calling order of functions.
 */
//inline void Example()
//{
//    constexpr int w = 720;
//    constexpr int h = 540;
//    constexpr int depth = 3;
//    DeviceCameraData camera;
//
//    Initialize<<<1,1>>>(w, h, depth); //Set up memory buffers.
//
//    while(true)
//    {
//        PreRenderSetup<<<1,1>>>(camera); //Generate primary rays.
//
//        for(int d = 0; d < depth; ++d)
//        {
//            IntersectRays(); //Gets intersection points for primary and secondary rays.
//            Shade<<<1, 1 >>>(); //Creates shadow rays with their potential contribution. Creates new secondary rays.
//        }
//
//        ResolveShadowRays<<<1, 1>>>(); //Resolves all shadow rays generated by the shading.
//        PostProcess<<<1,1>>>(); //Denoising, upscaling, motion blur dof etc.
//    }
//}



//void Initialize(const std::uint32_t a_ScreenWidth, const std::uint32_t a_ScreenHeight, const std::uint32_t a_Depth)
//{
//    //TODO:
//    /*
//     * - Pixel buffer swap chain (once for current and one for previous frame). Each buffer contains the direct, indirect and specular light contribution per pixel (RGB). Primary ray also stored.
//     *
//     * - Ray batch for primary rays. Size is w * h * sizeof(PrimaryRay). Primary ray has direction, origin, potential contribution scalar.
//     *
//     * - Shadow ray batch size w * h * 2 * depth * sizeof(ShadowRay). Shadow ray has direction, origin, max distance, potential contribution, light channel index.
//     *
//     * - Intersection data size w * h * sizeof(IntersectionData). IntersectionData holds ID of the mesh and triangle for later lookup.
//     *
//     */
//}

CPU_ONLY void PreRenderSetup(const SetupLaunchParameters& a_SetupParams)
{
    //Generate rays based on the camera.
    GenerateRays(a_SetupParams);

    //Generate motion vectors from the previous frame.
    GenerateMotionVectors();
}

CPU_ONLY void IntersectRays()
{
    //TODO
    /*
     * - Call Optix from the CPU to intersect all the rays in the ray batch. This fills the intersection data buffer.
     */
}

CPU_ONLY void Shade(const ShadingLaunchParameters& a_ShadingParams)
{
    //TODO
    /*
     * - Implement the below functions.
     * - Access to intersection data, as well as the ray resulting in this shading for chained BRDF scaling.
     */

    ShadeIndirect(); //Generate secondary rays.
    ShadeSpecular(); //Generate shadow rays for specular highlights.
    ShadeDirect();   //Generate shadow rays for direct lights.
}

CPU_ONLY void ResolveShadowRays()
{
    //TODO
    /* - Call Optix from the CPU to intersect all the rays in the shadow ray batches.
     *   If a ray intersects anything before max distance the radiance does not contribute.
     *   If a ray doesnt intersect anything before max distance, the radiance should be accumulated in the right channel.
     * - Parallellize the shadow ray resolving to be efficient but also thread safe. Some shadow rays affect the same output pixel.
     * Note:
     * - Only the first depth contributes to direct light. The other depths all add up in indirect.
     * - Each shadow rays potential contribution must already be scaled down by the entire paths bounce BRDFs at this point.
     */
}


CPU_ONLY void PostProcess(const PostProcessLaunchParameters& a_PostProcessParams)
{
    //TODO
    /*
     * Not needed now. Can be implemented later.
     * For now just merge the final light contributions to get the final pixel color.
     */
    Denoise();
    MergeLightChannels();
    DLSS();
    PostProcessingEffects();
}

CPU_ONLY void GenerateRays(const SetupLaunchParameters& a_SetupParams)
{
    const float3 u = a_SetupParams.m_Camera.m_Up;
    const float3 v = a_SetupParams.m_Camera.m_Right;
    const float3 w = a_SetupParams.m_Camera.m_Forward;
    const float3 eye = a_SetupParams.m_Camera.m_Position;
    const int2 dimensions = make_int2(a_SetupParams.m_Resolution.x, a_SetupParams.m_Resolution.y);
    const int numRays = dimensions.x * dimensions.y;

    const int blockSize = 256;
    const int numBlocks = (numRays + blockSize - 1) / blockSize;

    //TODO pass buffer
    GenerateRay<<<numBlocks, blockSize>>>(numRays, nullptr , u, v, w, eye, dimensions);
}

CPU_ONLY void GenerateMotionVectors()
{
}

GPU void ShadeDirect()
{
}

GPU void ShadeSpecular()
{
}

GPU void ShadeIndirect()
{
}

GPU void Denoise()
{
}

GPU void MergeLightChannels()
{
}

GPU void DLSS()
{
}

GPU void PostProcessingEffects()
{
}

GPU void GenerateRay(int a_NumRays, RayData* a_Buffer, const float3& a_U, const float3& a_V, const float3& a_W,
                     const float3& a_Eye, const int2& a_Dimensions)
{
    int index = blockIdx.x * blockDim.x + threadIdx.x;
    int stride = blockDim.x * gridDim.x;

    for (int i = index; i < a_NumRays; i += stride)
    {
        //Convert the index into the screen dimensions.
        const int screenY = i / a_Dimensions.x;
        const int screenX = i - (screenY * a_Dimensions.x);

        float3 direction = make_float3(static_cast<float>(screenX) / a_Dimensions.x,
                                       static_cast<float>(screenY) / a_Dimensions.y, 0.f);
        float3 origin = a_Eye;

        direction.x = -(direction.x * 2.0f - 1.0f);
        direction.y = -(direction.y * 2.0f - 1.0f);
        direction = normalize(direction.x * a_U + direction.y * a_V + a_W);

        RayData ray { origin, direction, make_float3(1.f, 1.f, 1.f) };
        a_Buffer[i] = ray;
    }
}