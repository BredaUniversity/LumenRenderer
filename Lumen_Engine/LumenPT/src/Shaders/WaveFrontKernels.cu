#include "./CppCommon/WaveFrontKernels.cuh"

/*
 * Example calling order of functions.
 */
inline void Example()
{
    constexpr int w = 720;
    constexpr int h = 540;
    constexpr int depth = 3;
    DeviceCameraData camera;

    Initialize<<<1,1>>>(w, h, depth); //Set up memory buffers.

    while(true)
    {
        PreRenderSetup<<<1,1>>>(camera); //Generate primary rays.

        for(int d = 0; d < depth; ++d)
        {
            IntersectRays(); //Gets intersection points for primary and secondary rays.
            Shade<<<1, 1 >>>(); //Creates shadow rays with their potential contribution. Creates new secondary rays.
        }

        ResolveShadowRays<<<1, 1>>>(); //Resolves all shadow rays generated by the shading.
        PostProcess<<<1,1>>>(); //Denoising, upscaling, motion blur dof etc.
    }
}



CPU void Initialize(const std::uint32_t a_ScreenWidth, const std::uint32_t a_ScreenHeight, const std::uint32_t a_Depth)
{
    //TODO:
    /*
     * - Pixel buffer swap chain (once for current and one for previous frame). Each buffer contains the direct, indirect and specular light contribution per pixel (RGB). Primary ray also stored.
     *
     * - Ray batch for primary rays. Size is w * h * sizeof(PrimaryRay). Primary ray has direction, origin, potential contribution scalar.
     *
     * - Shadow ray batch size w * h * 2 * depth * sizeof(ShadowRay). Shadow ray has direction, origin, max distance, potential contribution, light channel index.
     *
     * - Intersection data size w * h * sizeof(IntersectionData). IntersectionData holds ID of the mesh and triangle for later lookup.
     *
     */
}

CPU void PreRenderSetup(const DeviceCameraData& a_Camera)
{
    //TODO
    /*
     * - Use the camera to generate rays. These rays 
     * - Implement motion vectors
     */

    //Generate rays based on the camera.
    GenerateRays();

    //Generate motion vectors from the previous frame.
    GenerateMotionVectors();
}

CPU_ONLY void IntersectRays()
{
    //TODO
    /*
     * - Call Optix from the CPU to intersect all the rays in the ray batch. This fills the intersection data buffer.
     */
}

CPU void Shade()
{
    //TODO
    /*
     * - Implement the below functions.
     * - Access to intersection data, as well as the ray resulting in this shading for chained BRDF scaling.
     */

    ShadeIndirect(); //Generate secondary rays.
    ShadeSpecular(); //Generate shadow rays for specular highlights.
    ShadeDirect();   //Generate shadow rays for direct lights.
}

CPU void ResolveShadowRays()
{
    //TODO
    /*
     * - Parallellize the shadow ray resolving to be efficient but also thread safe. Some shadow rays affect the same output pixel.
     * Note:
     * - Only the first depth contributes to direct light. The other depths all add up in indirect.
     * - Each shadow rays potential contribution must already be scaled down by the entire paths bounce BRDFs at this point.
     */
}


CPU void PostProcess()
{
    //TODO
    /*
     * Not needed now. Can be implemented later.
     * For now just merge the final light contributions to get the final pixel color.
     */
    Denoise();
    MergeLightChannels();
    DLSS();
    PostProcessingEffects();
}